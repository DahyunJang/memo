* tips and tricks
- mutex_lock 이 블락 안에서만 유효하도록 짜놓음
- override 표현은 override하는 함수의 base가 virtual 함수임을 확인한다.
- using ServableName = string;
  using Version = int64;
  using VersionMap =
      std::map<Version, ServableStateAndTime, std::greater<Version>>;
  using ServableMap = std::map<ServableName, VersionMap>;
- cpp 에서 스트럭트와 클래스의 차이는 디폴트가 퍼블릭이냐 프라이빗이냐 뿐임.
- 스트럭트에 컨스트럭터도 있을 수 있음
- mutable variable -> can be changed in const function
- decltype -> 정의된 타입 반환
- map 에서 first 가 인덱스고 second가 데이터
-  static auto* registry = new Registry(); -> static 이어서 한 번만.
- 로그를 적는 각종 팩토리들을 등록하게 되어있음.


* word-dict
- oblivious : 의식하지 못하는
- harness : 벨트, 긴밀히 협조하는
- delegate : 위임하다. 대표
* 'core' folder
** loader
- servable: data, algorithm
- loader : stream of specific versioned servable
*** loader
**** estimate resource
- load : fetches any dat that needs to be loaded before using the servable
**** unload
**** servable
- load ~ unload 사이에만 not null
*** ResourceUnsafeLoader : public Loader
- 불안정한 리소스를 사용할 때 상태 체크를 사용할 필요는 없으니까 Status::OK()를 리턴하는 서브 클래스
** loader_harness.h
- 매니저가 로더를 소유하기 전에 대화하는 것.  (어댑터?)
- 전체적인 servable의 상태를 관리
*** state
knew -> kLoading
-> kReady (load is finished)
-> kQuiescing (is going to unavailable for serving)
-> kunloading
-> kDisabled (unload is finiished)
-> kError
- 각 상태 사이 사이 transition을 할 수 있음
*** Options
- retry 할 수, retry 간격, 에러시 콜백함수 설정 가능
*** load
- 보통은 다 상태를 바꿔주기만 하는 함수.
- 얘는 retry(리트라이 제약 조건 안에서 실행 해줌)함수 부른 다음 상태 변화
*** unload
- 언로드 부르기 전에 kQuiesced -> kUnloading
- 언로드 부르고 kUnloading -> kDisabled
** servable_id
- ServableId sturct 는 이름과 버전을 갖는다
- 해시, operator 정의
** servable_data
- ServableId, Status, T data를 갖고 있음
- status 는 컨스트럭터에서 설정되는데,
데이터 없고 status 에러 거나
status ok와 데이터 두가지 버전으로 컨스터럭터
- T는 move_constructible 해야 하며
- DataOrdie 는 return data_
- ConsumeDatatOrDie 는 return std::move(DataOrdie)
** servable_handle
*** UntypedServableHandle
- manager가 타입 없이 사용하려고?
- servable() 함수의 리턴형이 AnyPtr임
- 프론트에서 잡고 있으면 리로딩시 딜레이 발생할 수 있으므로 최대한 잡지 말아야.
*** ServableHandle
- manager와 프랜드
- 내부의 servable_을 리턴함.
- 클래스 생성시 untyped_handle_->servable().get<T> 로 servable_ set
*** SharedPtrHandle
- UntypedServableHandle
- servable id와 shared_ptr형태의 로더를 갖는다. (초기화시에는 move으로 로더 가져옴)
** servable_state_monitor
- servable 스테이트를 관리하는 스테이트, 로드 시간에 대한 맵임.
- 모니터는 ServableState 버스를 subscribe
- 특정 state에 도달하면 노티 함수를 실행
-  버스에서 스테이트 변경에 대한 정보가 날아다님..
** log_collector

* util
** any_ptr
- type-safe void* 같은 것인데, 콜러가 잘못 사용한다면 null로 나타나게.
- ptr을 받아서 (ptr.get<string>!=nullptr) 이런 식으로..
- 지나치게 긴 타입 체크 문은 패턴적으로 좋지 않음.
- 내부에 type, const를 제거해서 포인터를 들고오고, get시 원래 타입으로 캐스팅
- ptr_(const_cast<void*>(reinterpret_cast<const void*>(ptr))) {}
- reinterpret 캐스트는 c에서 생각하는 형변환이랑 비슷함.
- typename T로 시작하는 블록 안에서 static int dummy 에 대한 주소를 반환 -> 타입에 대한 아이디로 사용 (쩐당...)
